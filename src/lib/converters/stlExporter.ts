interface STLExportOptions {
    binary?: boolean
}

export function exportSTL(
    meshData: {
        vertices: Float32Array
        indices: Uint32Array
        normals?: Float32Array
    },
    options: STLExportOptions = {}
): ArrayBuffer | string {
    const { binary = true } = options

    if (binary) {
        return exportBinarySTL(meshData)
    } else {
        return exportASCIISTL(meshData)
    }
}

function exportBinarySTL(meshData: {
    vertices: Float32Array
    indices: Uint32Array
    normals?: Float32Array
}): ArrayBuffer {
    console.log('[STL Export] Starting binary export')
    const triangleCount = meshData.indices.length / 3
    console.log('[STL Export] Triangle count:', triangleCount)
    const bufferSize = 80 + 4 + triangleCount * 50 // Header + count + triangles
    console.log('[STL Export] Buffer size:', bufferSize, 'bytes')

    const buffer = new ArrayBuffer(bufferSize)
    const view = new DataView(buffer)

    // Header (80 bytes)
    const header = 'Binary STL generated by File Conversion Studio'
    for (let i = 0; i < 80; i++) {
        view.setUint8(i, i < header.length ? header.charCodeAt(i) : 0)
    }

    // Triangle count
    view.setUint32(80, triangleCount, true)
    console.log('[STL Export] Header written')

    let offset = 84

    // Write triangles
    for (let i = 0; i < meshData.indices.length; i += 3) {
        const i1 = meshData.indices[i] * 3
        const i2 = meshData.indices[i + 1] * 3
        const i3 = meshData.indices[i + 2] * 3

        // Get vertices
        const v1 = [meshData.vertices[i1], meshData.vertices[i1 + 1], meshData.vertices[i1 + 2]]
        const v2 = [meshData.vertices[i2], meshData.vertices[i2 + 1], meshData.vertices[i2 + 2]]
        const v3 = [meshData.vertices[i3], meshData.vertices[i3 + 1], meshData.vertices[i3 + 2]]

        // Calculate normal
        const normal = calculateNormal(v1, v2, v3)

        // Write normal
        view.setFloat32(offset, normal[0], true); offset += 4
        view.setFloat32(offset, normal[1], true); offset += 4
        view.setFloat32(offset, normal[2], true); offset += 4

        // Write vertices
        view.setFloat32(offset, v1[0], true); offset += 4
        view.setFloat32(offset, v1[1], true); offset += 4
        view.setFloat32(offset, v1[2], true); offset += 4

        view.setFloat32(offset, v2[0], true); offset += 4
        view.setFloat32(offset, v2[1], true); offset += 4
        view.setFloat32(offset, v2[2], true); offset += 4

        view.setFloat32(offset, v3[0], true); offset += 4
        view.setFloat32(offset, v3[1], true); offset += 4
        view.setFloat32(offset, v3[2], true); offset += 4

        // Attribute byte count (unused)
        view.setUint16(offset, 0, true); offset += 2

        // Log progress every 1000 triangles
        if (i % 3000 === 0 && i > 0) {
            console.log(`[STL Export] Written ${i / 3}/${triangleCount} triangles`)
        }
    }

    console.log('[STL Export] All triangles written')
    return buffer
}

function exportASCIISTL(meshData: {
    vertices: Float32Array
    indices: Uint32Array
}): string {
    let stl = 'solid model\n'

    for (let i = 0; i < meshData.indices.length; i += 3) {
        const i1 = meshData.indices[i] * 3
        const i2 = meshData.indices[i + 1] * 3
        const i3 = meshData.indices[i + 2] * 3

        const v1 = [meshData.vertices[i1], meshData.vertices[i1 + 1], meshData.vertices[i1 + 2]]
        const v2 = [meshData.vertices[i2], meshData.vertices[i2 + 1], meshData.vertices[i2 + 2]]
        const v3 = [meshData.vertices[i3], meshData.vertices[i3 + 1], meshData.vertices[i3 + 2]]

        const normal = calculateNormal(v1, v2, v3)

        stl += `  facet normal ${normal[0]} ${normal[1]} ${normal[2]}\n`
        stl += `    outer loop\n`
        stl += `      vertex ${v1[0]} ${v1[1]} ${v1[2]}\n`
        stl += `      vertex ${v2[0]} ${v2[1]} ${v2[2]}\n`
        stl += `      vertex ${v3[0]} ${v3[1]} ${v3[2]}\n`
        stl += `    endloop\n`
        stl += `  endfacet\n`
    }

    stl += 'endsolid model\n'
    return stl
}

function calculateNormal(v1: number[], v2: number[], v3: number[]): number[] {
    // Edge vectors
    const e1 = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]]
    const e2 = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]]

    // Cross product
    const normal = [
        e1[1] * e2[2] - e1[2] * e2[1],
        e1[2] * e2[0] - e1[0] * e2[2],
        e1[0] * e2[1] - e1[1] * e2[0]
    ]

    // Normalize
    const length = Math.sqrt(normal[0] ** 2 + normal[1] ** 2 + normal[2] ** 2)
    if (length > 0) {
        normal[0] /= length
        normal[1] /= length
        normal[2] /= length
    }

    return normal
}
